<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Japho Blog</title>
    <description>The shortest answer is doing.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 03 Nov 2018 23:21:25 +0800</pubDate>
    <lastBuildDate>Sat, 03 Nov 2018 23:21:25 +0800</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>理解引用计数</title>
        <description>&lt;p&gt;Objective-C语言使用引用技术来管理内存，也就是说，每个对象都有可以递增或递减的计数器。如果想使某个对象继续存活，就递增其引用计数；用完之后，就递减其引用计数，计数变为0时，表示没有人关注这个对象，自然就把他释放了。&lt;/p&gt;

&lt;h3 id=&quot;引用计数工作原理&quot;&gt;引用计数工作原理&lt;/h3&gt;

&lt;p&gt;引用计数的架构下，对象有个计数器，用以表示当前有多少事物想令此对象存活下去，在Objective-C中叫做“引用计数”。&lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;协议中声明了一下三个方法用于操作计数器，以递增或递减引用计数。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;retain&lt;/code&gt; 递增引用计数；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt; 递减引用计数；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt; 待稍后清理“自动释放池”时，再去递减其引用计数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看引用计数的方法叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;retainCount&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;对象在创建出来时，其引用计数至少为1，若想继续存活，则调用&lt;code class=&quot;highlighter-rouge&quot;&gt;retain&lt;/code&gt;方法。要是某部分代码不再调用此对象，不想令其存活，则调用&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt;方法。当引用计数为0时，对象就会被回收。这时，系统会将其占用的内存标记为“可重用”（&lt;code class=&quot;highlighter-rouge&quot;&gt;reuse&lt;/code&gt;）。此时所有指向该对象的引用都变得无效了。&lt;/p&gt;

&lt;p&gt;下列代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableArray *array = [[NSMutableArray alloc] init];
NSNumber *number = [[NSNumber alloc] initWithNumber:1337];
[array addObject:number];
[number release];
//do somthing with array;
[array release];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于上述代码调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;，所以在ARC下无法编译。在&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;中，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt;方法所返回的对象由调用者所有。也就是说，调用者，已通过alloc方法表达了相对该对象继续存活的意愿。这里可以肯定此时引用计数一定大于1。
创建完成后，把&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;加入数组中，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;addObject:&lt;/code&gt;方法时，数组也会在&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;上调用&lt;code class=&quot;highlighter-rouge&quot;&gt;retain&lt;/code&gt;方法，以继续保留此对象。此时，引用计数至少为2。接下来，代码不再需要&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;对象了，于是将其释放，此时引用计数至少为1，这样就不能照常使用&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;变量了。调用&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;之后，已经无法保证所指对象是否仍然存活。不过这里我们知道&lt;code class=&quot;highlighter-rouge&quot;&gt;array&lt;/code&gt;还对&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;存在引用。但是不要假设这一对象一定存活，也就是说，不要编写下列代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableArray *array = [[NSMutableArray alloc] init];
NSNumber *number = [[NSNumber alloc] initWithNumber:1337];
[array addObject:number];
[number release];
NSLog(@&quot;number = %@&quot;,number);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述代码仍可执行，但如果调用&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;之后，基于某种原因，引用计数变为0，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;对象所占有内存也会被回收，这样，再去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog&lt;/code&gt;就可能造成崩溃。这里只是说“可能”，并不是“一定”，因为对象所占有的内存在“解除分配”之后，只是放回“可用内存池”（&lt;code class=&quot;highlighter-rouge&quot;&gt;avaiable pool&lt;/code&gt;）。如果执行&lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog&lt;/code&gt;时尚未覆写对象内存，那么该对象仍然有效，这是程序并不会崩溃，不过过早释放对象而造成的bug将会很难调试。&lt;/p&gt;

&lt;p&gt;为了避免在不经意间使用了无效对象，一般调用完&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;之后都会进行清空指针。这就能保证不会出现可能指向无效指针对象的指针。（悬挂指针）。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSNumber *number = [[NSNumber alloc] initWithNumber:1337];
[array addObject:number];
[number release];
number = nil;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;属性存取方法中的内存管理&quot;&gt;属性存取方法中的内存管理&lt;/h3&gt;

&lt;p&gt;访问属性时，会用到相关实例变量的&lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt;方法及&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;方法。若属性为&lt;code class=&quot;highlighter-rouge&quot;&gt;strong&lt;/code&gt;关系，则设置的属性值会保留，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)setFoo:(id)foo
{
[foo retain];
[_foo release];
_foo = foo;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此方法将保留新值并释放旧值，然后更新实例变量。&lt;/p&gt;

&lt;h3 id=&quot;自动释放池&quot;&gt;自动释放池&lt;/h3&gt;

&lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;releas&lt;/code&gt;e会立刻递减对象的保留计数，有时可能令系统回收此对象，然后有时候改为调用&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt;，此方法会在稍后递减计数，通常是在下一次“事件循环”时递减，不过也可能会更早。
&lt;code class=&quot;highlighter-rouge&quot;&gt;autoreleas&lt;/code&gt;e能延长对象生命周期，使其在跨越方法调用便捷后依然可以存活一段时间。&lt;/p&gt;

&lt;h3 id=&quot;循环引用&quot;&gt;循环引用&lt;/h3&gt;

&lt;p&gt;呈环状互相引用多个对象，这将导致内存泄漏。因为循环中的对象其引用计数不会降为0，对于循环中的每个对象来说，至少还有另外一个对象引用他。通常采用“弱引用”解决，或者从外界命令循环中的某个对象不再保留另外一个对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其引用计数至少为1。若引用计数为正，则对象继续存活，当引用计数降为0时，对象就被销毁了。&lt;/li&gt;
  &lt;li&gt;在对象生命周期中，其余对象通过引用来保留或者释放此对象。保留与释放操作分别会递增及递减引用计数。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 15 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/15/%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/15/%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>以ARC简化引用计数</title>
        <description>&lt;p&gt;使用ARC时，引用计数实际上还是要执行的，只不过保留与释放操作现在是由ARC自动添加的。由于ARC会自动执行&lt;code class=&quot;highlighter-rouge&quot;&gt;retain&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt;等操作，所以直接在ARC下调用这些内存管理方法是非法的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例如以下方法：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;retain&lt;/li&gt;
  &lt;li&gt;release&lt;/li&gt;
  &lt;li&gt;autorelease&lt;/li&gt;
  &lt;li&gt;dealloc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;直接调用这些方法会产生编译错误。&lt;/p&gt;

&lt;h3 id=&quot;使用arc时必须遵循的方法命名规则&quot;&gt;使用ARC时必须遵循的方法命名规则&lt;/h3&gt;

&lt;p&gt;若以以下词语开头，其返回的对象归调用者所有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;alloc&lt;/li&gt;
  &lt;li&gt;new&lt;/li&gt;
  &lt;li&gt;copy&lt;/li&gt;
  &lt;li&gt;mutableCopy&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;归调用者所有的意思是：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;调用上述四种方法的那段代码要负责释放方法所返回的对象。也就是说，这些对象的保留计数是正值，而调用了这四种方法的那段代码要将其中一次保留操作抵消掉。&lt;/p&gt;

  &lt;p&gt;除了自动调用“保留”与“释放”的方法之外，使用ARC时，他可以在编译期把能够相互抵消的&lt;code class=&quot;highlighter-rouge&quot;&gt;retain&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;auitorelease&lt;/code&gt;操作约简。如果发现在同一个对象上执行了多次“保留”与“释放”操作，那么ARC有时也可以成对的移除这两个操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;变量的内存管理语义&quot;&gt;变量的内存管理语义&lt;/h3&gt;

&lt;p&gt;ARC会用一种安全的方式来设置：先保留新值，再释放旧值，最后设置实例变量。使用ARC之后，无需考虑这种“边界情况”。&lt;/p&gt;

&lt;p&gt;在应用程序中，可用下列修饰符来改变局部变量与实例变量的语义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__strong&lt;/code&gt;：默认语义，保留这个值&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__unsafe_unretained&lt;/code&gt;：不保留这个值，（可能不安全，下次使用变量时，其对象可能已经被回收）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt;：不保留这个值，但是变量可以安全使用，因为如果系统把这个对象回收了，那么变量也会被自动清空。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__autoreleasing&lt;/code&gt;：把对象“按引用传递”给方法时，使用这个特殊的修饰符，这个值在方法返回时自动释放。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如：想令实力变脸的语义与不使用ARC时相同，可以运用&lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;__unsafe_unretained&lt;/code&gt;修饰符。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface EOCClass  :  NSObject
{
id __weak _weakObject;
id __unsafe_unretained  _unsafeUnretainedObject;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;arc如何清理实例变量&quot;&gt;ARC如何清理实例变量&lt;/h3&gt;

&lt;p&gt;非Objective-C的对象，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;CoreFoundation&lt;/code&gt;框架中的对象，或是由&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc()&lt;/code&gt;分配在堆中的内存，这时仍然需要手动清理。这里调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;方法时，并不需要调用超类的&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;，在ARC下不能直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;。ARC会自动生成代码并运行此方法，生成的代码中会自动调用超类的&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc()&lt;/code&gt;方法。可以这么写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-  (void)dealloc
{
CFRelease(_coreFoundationObject);
free(_heapAllocatedMemoryBlob);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;覆写内存管理方法&quot;&gt;覆写内存管理方法&lt;/h3&gt;

&lt;p&gt;不使用ARC时，可以覆写内存管理方法，但是在ARC环境下，不能这么做，因为会干扰ARC分析对象生命周期的工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有ARC之后，程序员就无须担心内存管理问题了。使用ARC来编程，可省去勒种的许多“样板代码”。&lt;/li&gt;
  &lt;li&gt;ARC管理对象生命周期的办法基本上就是：在合适的地方插入“保留”及“释放”操作。在ARC环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手动执行“保留”及“释放”操作。&lt;/li&gt;
  &lt;li&gt;由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC将此确定为开发者必须遵守的规定。
ARC只负责管理Objective-C对象的内存。&lt;code class=&quot;highlighter-rouge&quot;&gt;CoreFoundation&lt;/code&gt;对象不归ARC管理，开发者需要在合适的时间调用&lt;code class=&quot;highlighter-rouge&quot;&gt;CFRetain&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;CFRelease&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 10 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/10/%E4%BB%A5ARC%E7%AE%80%E5%8C%96%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/10/%E4%BB%A5ARC%E7%AE%80%E5%8C%96%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>在dealloc方法中只释放引用并解除监听</title>
        <description>&lt;p&gt;对象经历生命周期后，就会被系统回收，这时就会执行&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;方法。在每个对象的生命周期内，此方法只执行一次。不应该自己调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;方法，运行期系统会在适当的时候调用他，而且一旦调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;之后，对象就不在有效了，后续调用的方法均是无效的。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;方法中主要是释放对象所拥有的引用，把所有的Objective-C对象都释放掉，ARC会在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;中自动添加这些释放代码。对象所拥有的其他非Objective-C对象也要释放，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;CoreFoundation&lt;/code&gt;对象就必须手动进行释放，因为他是基于C的API生成的。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;方法中，通常还需要将原来配置过的监听方法都清理掉。如果用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSNotificationCenter&lt;/code&gt;给对象注册了某种通知，那么一般应该在这里注销，这样，通知系统就不会再把通知发送给回收后的对象了，如果还发送通知，则必然会引起程序崩溃。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dealloc
{
CFRelease(coreFoundationObject);
[[NSNotificationCenter  defaultCenter]  removeObserver:self];
/*
**    如果非ARC情况下，还需调用
[super dealloc];
*/
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;方法的那个线程会执行“最终的释放操作”，令对象的保留计数降为0，而某些方法必须在特定的线程中调用（主线程）。若在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;调用了哪些方法，则无法保证当前这个线程就是那些方法所需的线程。通过正常的代码编写方式，无论如何都无法保证其会安全运行在正确的线程上，因为对象正处于“正在回收的状态”，为了指明此状况，运行期系统已经改动了对象的内部数据结构。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;里也不要调用属性的&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt;方法，因为这些方法可能会被重写，并与其中做了一些无法在回收阶段安全执行的操作。此外，属性可能处于“键值观察”机制的监控下，该属性的观察者可能会在属性值改变时“保留”或者使用这个即将回收的对象，这会令程序状态失调，导致一些莫名其妙的错误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;方法里，应该做的事情就是释放指向其他对象的引用，并取消原来注册的&lt;code class=&quot;highlighter-rouge&quot;&gt;KVO&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;NSNotificationCenter&lt;/code&gt;等通知，不要做其他事情。&lt;/li&gt;
  &lt;li&gt;如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放这种资源。这样的类要和其使用者的约定：在用完资源之后必须调用&lt;code class=&quot;highlighter-rouge&quot;&gt;close&lt;/code&gt;方法。&lt;/li&gt;
  &lt;li&gt;执行异步任务的方法不应该在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;里调用，只能在正常状态下执行的那些方法也不应该在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;里调用，因为此时对象已经处于正在回收的状态了。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/02/%E5%9C%A8dealloc%E6%96%B9%E6%B3%95%E4%B8%AD%E5%8F%AA%E9%87%8A%E6%94%BE%E5%BC%95%E7%94%A8%E5%B9%B6%E8%A7%A3%E9%99%A4%E7%9B%91%E5%90%AC/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/02/%E5%9C%A8dealloc%E6%96%B9%E6%B3%95%E4%B8%AD%E5%8F%AA%E9%87%8A%E6%94%BE%E5%BC%95%E7%94%A8%E5%B9%B6%E8%A7%A3%E9%99%A4%E7%9B%91%E5%90%AC/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>勿在分类中声明属性</title>
        <description>&lt;p&gt;尽管在技术上说，分类中可以声明属性，但是还是要尽量避免这种做法。因为，分类无法向类中新增实例变量，因此，他们无法把实现属性所需的实例变量合成出来。这时，需要在分类中为该属性实现&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;  &amp;amp;&amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt;方法，此时，可将存取方法生命为&lt;code class=&quot;highlighter-rouge&quot;&gt;@dynamic&lt;/code&gt;，就是说，这些方法在运行期再去提供，编译器目前是看不到的。&lt;/p&gt;

&lt;p&gt;利用关联对象解决这个问题：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;objc/runtime.h&amp;gt;

static const char *propertyKey =  &quot;porpertyKey&quot;;

@implementation Person

-  (NSArray  *)friends
{
return objc_getAssociatedObject(self,  porpertyKey);
}

-  (void)setFriends:(NSArray  *)friends
{
objc_setAssociatedObject(self,  porpertyKey,  firends,  OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种方法在技术上可行，但是并不太理想，要把相似的代码写很多遍，而且在内存管理上容易出现错误。例如在为属性实现存取方法时，经常忘记遵从内存管理语义，而且修改属性特质（&lt;code class=&quot;highlighter-rouge&quot;&gt;attribute&lt;/code&gt;）时，也不能忘记修改存取方法。这里还要考虑可变对象的问题，是否传进一个不可变对象，需要生成一个可变对象的问题。&lt;/p&gt;

&lt;p&gt;所以应当把分类理解成一种手段，目的在于扩展类的功能，而非封装数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;把封装数据所用的全部属性都定义在类的主接口里。&lt;/li&gt;
  &lt;li&gt;在“&lt;code class=&quot;highlighter-rouge&quot;&gt;class-continuation&lt;/code&gt;分类”之外的其他分类中，可以定义存取方法，但是尽量不要定义属性。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 01 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/01/%E5%8B%BF%E5%9C%A8%E5%88%86%E7%B1%BB%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%B1%9E%E6%80%A7/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/01/%E5%8B%BF%E5%9C%A8%E5%88%86%E7%B1%BB%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%B1%9E%E6%80%A7/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>编码习惯问题</title>
        <description>&lt;h2 id=&quot;将类的实现代码分散到便于管理的数个分类中&quot;&gt;将类的实现代码分散到便于管理的数个分类中&lt;/h2&gt;

&lt;p&gt;当类中方法及实现过多的时候，可以考虑用Objective-C的“分类”机制，把代码按逻辑划分到几个分区中。通过分类机制，可以把类代码分成很多个易于管理的小块，以便单独检视。此外，使用分类还有一个原因，就是便于调试。对于某个分类中的所有方法来说，分类名称都会出现在其符号中，例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- [Person(FriendShip)  addFriend:]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编写程序库时，可以考虑创建&lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;分类，经常会遇到一些方法，这些方法不是公共的API，但却非常适合在程序库内部使用，此时应该创建爱你&lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;分类，如果程序中某些地方要用到这些方法，就引入这个分类文件。二分类的头文件不随程序库一并公开，于是，该代码库的使用者不会知晓库里还有这些私有方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用分类机制把勒种的实现代码划分成易于管理的小块。&lt;/li&gt;
  &lt;li&gt;将应该视为“私有”的方法归入private分类中，以隐藏实现细节。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总是为第三方类的分类名称加前缀&quot;&gt;总是为第三方类的分类名称加前缀&lt;/h2&gt;

&lt;p&gt;分类机制通常用于向无源码的既有类中添加新功能，但在使用时会存在问题：分类中的方法是直接添加在类中的，将分类方法加入类中这一操作是在运行期系统加载分类时完成的。运行时系统会把分类中所实现的每个方法都加入类的方法列表中，如果类中本来就存在这个方法，那么就会产生覆盖，若发生多次覆盖，则以最后一次为准。&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface NSString  (ABC_HTTP)

- (NSString  *)abc_urlEncodedString;

- (NSString  *)abc_urlDecodedString;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;向第三方类中添加分类时，总应给其名称加上专用前缀。&lt;/li&gt;
  &lt;li&gt;向第三方类中添加分类时，总应给其的方法加上专用前缀。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用class-continuation分类隐藏实现细节&quot;&gt;使用“class-continuation分类”隐藏实现细节&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;class-continuation&lt;/code&gt;分类向类中新增实例变量。&lt;/li&gt;
  &lt;li&gt;如果某属性在主接口中声明为“只读”，而类内部又要用&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;方法修改次数性，那么就在“&lt;code class=&quot;highlighter-rouge&quot;&gt;class-continuation&lt;/code&gt;分类”中将其扩展为“可读写”。&lt;/li&gt;
  &lt;li&gt;把私有方法的原型声明在“&lt;code class=&quot;highlighter-rouge&quot;&gt;class-continuation&lt;/code&gt;分类”中。&lt;/li&gt;
  &lt;li&gt;若想使用类所遵循的协议而不为人所知，则可于“&lt;code class=&quot;highlighter-rouge&quot;&gt;class-continuation&lt;/code&gt;分类”中声明。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;用僵尸对象调试内存管理问题&quot;&gt;用“僵尸对象”调试内存管理问题&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;系统在回收对象时，可以不将其真正的回收，而是把它转化为僵尸对象。通过环境变量&lt;code class=&quot;highlighter-rouge&quot;&gt;NSZombieEnabled&lt;/code&gt;可开启此功能。&lt;/li&gt;
  &lt;li&gt;系统会修改对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;isa&lt;/code&gt;指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接受者的消息，然后终止应用程序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;不要使用retaincount&quot;&gt;不要使用retainCount&lt;/h2&gt;

&lt;p&gt;ARC已经将此方法废弃了，在ARC中调用此方法，编译器会报错。&lt;/p&gt;

&lt;p&gt;此方法无用原因：他返回的引用计数只是某个给定时间点上的值，该方法并未考虑到系统会稍后吧自动释放池清空，因为不会将后续的释放操作从返回值里减去。所以这个值未必能真实的反映实际的保留计数。
我们不应该总是依赖保留计数的具体值来编码。即便是只为了调试，此方法也不是很有用。由于对象可能处在自动释放池中，所以其保留计数未必如想象中精确。而且其他程序库也有可能自行保留或释放对象，这都会扰乱保留计数的具体取值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对象的保留计数看似有用，实则不然，因为任何给定时间点上的“绝对保留计数”都无法反映对象生命期的全貌。&lt;/li&gt;
  &lt;li&gt;引入ARC之后，retainCount方法就正式废止了，在ARC下调用该方法会导致编译器报错。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;为常用的块类型创建typedef&quot;&gt;为常用的块类型创建typedef&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return_type (^block_name)(parameters)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了隐藏复杂的块类型，需要用到C语言中名为类型定义的特性。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int (^EOCSomeBlock)(BOOL  flag,  int value);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;声明变量时，把名称放在类型中间，并在前面加上“^”符号。以下来创建变量，直接使用新类型即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EOCSomeBlock  block =  ^(BOOL  flag,  int value){
//Impementation
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;以&lt;code class=&quot;highlighter-rouge&quot;&gt;typedef&lt;/code&gt;重新定义块类型，可令块变量用起来更加简单。&lt;/li&gt;
  &lt;li&gt;定义新类型时应遵从现有的命名习惯，勿使其名称与别的类型冲突。&lt;/li&gt;
  &lt;li&gt;不妨为同一块签名定义多个类型别名。如果需要重构的代码使用了块类型的某个别名，那么只需修改相应&lt;code class=&quot;highlighter-rouge&quot;&gt;typedef&lt;/code&gt;中的块签名即可，无需改动其他&lt;code class=&quot;highlighter-rouge&quot;&gt;typedef&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;用handler块来降低代码分散程度&quot;&gt;用handler块来降低代码分散程度&lt;/h2&gt;

&lt;p&gt;编写代码时，经常会遇到一种范式，就是“异步执行任务”。异步方法执行完任务后，需要以某种手段通知代码。实现这种功能有很多方法，常用技巧是委托协议令关注此事件的对象遵从该协议。对象成为&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt;之后，就可以在相关事件发生时得到通知了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

@class EOCNetWorkFetcher;
@protocol EOCNetWorkFetcherDelegate &amp;lt;NSObject&amp;gt;
- (void)netWorkFetcher:(EOCNetWorkFetcher *)fetcher didFinishWithData:(NSData *)data;
@end

@interface EOCNetWorkFetcher : NSObject
@property (nonatomic, weak) id&amp;lt;EOCNetWorkFetcherDelegate&amp;gt; delegate;
- (void)initWithUrl:(NSURL *)url;
- (void)start;
@end;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其他类调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)fetchFooData{
NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.xvideos.com&quot;];
EOCNetWorkFetcher *fetcher = [[EOCNetWorkFetcher alloc] initWithURL:url];
fetcher.delegate = self;
[fetcher start];
}

- (void)netWorkFetcher:(EOCNetWorkFetcher *)fetcher didFinishWithData:(NSData *)data
{
_fetcherFooData = data;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 29 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/29/%E5%B0%86%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E5%88%86%E6%95%A3%E5%88%B0%E4%BE%BF%E4%BA%8E%E7%AE%A1%E7%90%86%E7%9A%84%E6%95%B0%E4%B8%AA%E5%88%86%E7%B1%BB%E4%B8%AD/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/29/%E5%B0%86%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E5%88%86%E6%95%A3%E5%88%B0%E4%BE%BF%E4%BA%8E%E7%AE%A1%E7%90%86%E7%9A%84%E6%95%B0%E4%B8%AA%E5%88%86%E7%B1%BB%E4%B8%AD/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>理解Objective-C错误类型</title>
        <description>&lt;p&gt;ARC下默认情况非“异常安全”，如果抛出异常，本应在作用域末尾释放的对象将不会进行自动释放了。若想生成“异常安全”代码，通过设置编译器的标志来实现，不过将引入一些额外代码，在不抛出异常时，也会照样执行这部分代码。这里需要打开的标志叫做  &lt;code class=&quot;highlighter-rouge&quot;&gt;-fobjc-arc-exceptions&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Objective-C现在所采用的方法是：在极其罕见的情况下抛出异常，异常抛出之后，无需考虑回复问题，而此时应用程序退出。异常只应该应用于极其严重的错误上。在处理“不那么严重的错误”时，Objective-C使用的编程范式为：令方法返回0/nil，或者使用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSError&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSError&lt;/code&gt;更加灵活，因为经由此对象，可以把导致错误的原因回报给调用者。&lt;code class=&quot;highlighter-rouge&quot;&gt;NSError&lt;/code&gt;主要封装了三条信息&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Error domain（错误范围，字符串类型）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;错误发生的范围，也就是错误产生的根源，通常是由全局变量来定义，&lt;/p&gt;

  &lt;p&gt;例如：NSURLErrorDomain&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Error  Code（错误码，整型数）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;独有的错误代码，用于指明在某个范围内发生的错误，通常采用enum&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;User Info（用户信息，字典类型）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;有关于该错误的额外信息&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;设计API时，&lt;code class=&quot;highlighter-rouge&quot;&gt;NSError&lt;/code&gt;一般是通过委托模式来传递错误，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-  (void)connection:(NSURLConnection  *)connection didFailWithError:(NSError  *)error
{
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当发生错误时，会调用此方法进行处理，委托方法不一定需要实现，交给开发人员进行判断。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSError&lt;/code&gt;另一种常用方法：经由“输出参数”返回给调用者，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-  (BOOL)doSomething:(NSError  **)error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;传递给方法的参数是一个指针，二该指针又指向另外一个指针，这个指针指向&lt;code class=&quot;highlighter-rouge&quot;&gt;NSError&lt;/code&gt;对象，也可以把它当成&lt;code class=&quot;highlighter-rouge&quot;&gt;NSError&lt;/code&gt;对象的指针，如此，该方法不仅能有普通的返回值，还可以经由“输出参数”把&lt;code class=&quot;highlighter-rouge&quot;&gt;NSError&lt;/code&gt;对象回传给调用者。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSError  *error =  nil;
BOOl  rect =  [obj doSomething:&amp;amp;error];
if (error) 
{
//处理error
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;方法会返回布尔值，若关注具体错误，处理经由“输出参数”所返回的错误对象；若不关注，则可以给&lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt;传入&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BOOl  rect =  [obj doSomething:nil];
if (rect)
{
//存在错误，但不获取错误对象
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实际上，在使用ARC时，编译器会把&lt;code class=&quot;highlighter-rouge&quot;&gt;NSError ** &lt;/code&gt;转换成&lt;code class=&quot;highlighter-rouge&quot;&gt;NSError *__autoreleasing *&lt;/code&gt;，指针所指向的对象在方法执行完毕之后就会释放掉，所以这个对象必须是自动释放，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;doSomething:&lt;/code&gt;方法不能保证调用者在方法中创建的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSError&lt;/code&gt;释放掉，所以这里要加上&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;传递“输出参数”&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-  (BOOL)doSomething:(NSError  **)error
{
if (/* there was an error*/)
{
if (error)
{
*error = [NSError errorWithDomain:domain code:code userInfo:userInfo];
}
return NO;
}
else
{
return YES;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*error&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt;参数“解引用”，使&lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt;的指针指向新的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSError&lt;/code&gt;对象，注意：在解引用之前需保证&lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt;参数不能为&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;，会因为空指针解引用会导致段错误，使应用崩溃。&lt;/p&gt;

&lt;p&gt;错误码一般使用枚举类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;只有发生了可使整个应用程序崩溃的严重错误时，才使用异常。&lt;/li&gt;
  &lt;li&gt;在错误不那么严重的情况下，可以指派委托方法（&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt;）来处理错误。也可以把错误信息放在&lt;code class=&quot;highlighter-rouge&quot;&gt;NSError&lt;/code&gt;对象里，经由“输出参数”返回给调用者。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 28 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/28/%E7%90%86%E8%A7%A3Objective-C%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/28/%E7%90%86%E8%A7%A3Objective-C%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>通过委托与数据源协议进行对象间的通信</title>
        <description>&lt;p&gt;Objective-C不支持多继承，因此我们把某个类应该实现的一系列方法定义在协议里面。协议最常见的用途就是委托模式（&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt;），“分类”（&lt;code class=&quot;highlighter-rouge&quot;&gt;category&lt;/code&gt;），也是Objective-C的一种重要语言特性，利用分类机制，我们无需继承子类即可直接为当前类添加方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;委托模式的主旨：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口。以便成为其“委托对象”。这里“另一个对象”则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。&lt;/p&gt;

&lt;p&gt;这个模式可将数据与业务逻辑解耦。视图中知应包含显示数据所需的逻辑代码，而不应决定要显示何种数据以及数据之间如何交互等问题。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt;这个属性应该定义成&lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt;，而非&lt;code class=&quot;highlighter-rouge&quot;&gt;strong&lt;/code&gt;。因为两者之间必须为“费用有关系”。通常情况下，扮演&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt;的对象也要持有本对象，直到对象用完之后才会被释放。假如这里声明的时候用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;strong&lt;/code&gt;，这里就会造成“循环引用”，对象无法被释放掉。所以&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt;对象应该被声明为&lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt;，或者&lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_unretained&lt;/code&gt;，（区别在于&lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt;可在相关对象销毁时自动清空设置成&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;，不会造成野指针）。&lt;/p&gt;

&lt;p&gt;实现委托对象的办法是声明某个类遵从委托协议，然后把协议中想要实现的那些方法在类里实现出来。委托协议一般来说都是可选的（optional），因为委托者未必关心其中的所有方法，这里需要注意，如果在委托对象上调用了可选方法，则必须提前使用类型信息查询方法来判断这个委托对象能否响应相关选择子。
例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ([_delegate respondsToSelecto: @selector(networkFetcher:didReceiveData:)])
{
[_delegate networkFetcher:self didReceiveData:data];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象。&lt;/li&gt;
  &lt;li&gt;将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。&lt;/li&gt;
  &lt;li&gt;当某对象要从另外一个对象中获取数据时，可以使用委托模式。这种模式下，该模式也叫做“数据源协议”。&lt;/li&gt;
  &lt;li&gt;如果有必要，可实现含有段位的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中（delegate多次调用，后续检测多余，如果委托对象本身没有变化，不太可能会突然响应某个原来不能响应的选择子，这时可以考虑这种问题）。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 27 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/27/%E9%80%9A%E8%BF%87%E5%A7%94%E6%89%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/27/%E9%80%9A%E8%BF%87%E5%A7%94%E6%89%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>理解NSCopying协议</title>
        <description>&lt;p&gt;在需要拷贝对象时，要通过copy方法来完成，如果想令自己创建的类支持拷贝操作，那就需要实现NSCopying协议，次协议只有一个方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)copyWithZone:(NSZone *)zone;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;关于zone&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;开发时，会根据&lt;code class=&quot;highlighter-rouge&quot;&gt;zone&lt;/code&gt;把内存分成不同的“区”，不过现在默认程序只有一个区：“默认区”，尽管必须实现此方法，不必担心&lt;code class=&quot;highlighter-rouge&quot;&gt;zone&lt;/code&gt;参数。注意，这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;是由&lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;实现的，会以“默认区”为参数调用&lt;code class=&quot;highlighter-rouge&quot;&gt;copyWithZone:&lt;/code&gt;，所以需要实现的是&lt;code class=&quot;highlighter-rouge&quot;&gt;copyWithZone:&lt;/code&gt;方法，而非覆写&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一般的：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//特殊需要
@implentation Person
{
NSMutableSet *_friends;
}

- (id)copyWithZone:(NSZone *)zone
{
Person *copy = [[[self class] allocWithZone:zone] initWithFirstName:first andLastName:last];

/* 如果有特殊需要，例如保存特定的数据结构 */
copy-&amp;gt;_friends = [_friends mutableCopy];

return copy;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用“-&amp;gt;”语法，因为这里&lt;code class=&quot;highlighter-rouge&quot;&gt;friends&lt;/code&gt;变量并非属性，只是内部存在的一个成员变量。&lt;/p&gt;

&lt;p&gt;这里拷贝了&lt;code class=&quot;highlighter-rouge&quot;&gt;friends&lt;/code&gt;变量是防止原始数据修改后，导致新的复制过去的数据也会变化。若set对象是不可变的，这里则无需进行复制。&lt;/p&gt;

&lt;p&gt;若要实现&lt;code class=&quot;highlighter-rouge&quot;&gt;mutableCopy&lt;/code&gt;方法，同样的，遵守&lt;code class=&quot;highlighter-rouge&quot;&gt;NSMutableCopying&lt;/code&gt;协议，实现&lt;code class=&quot;highlighter-rouge&quot;&gt;mutableCopyWithZone:&lt;/code&gt;，
无论当前实例是否可变，若需要可变版本的拷贝，则调用&lt;code class=&quot;highlighter-rouge&quot;&gt;mutableCopy&lt;/code&gt;，同理，需要不可变的拷贝，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;来获取。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于NSArry &amp;amp;&amp;amp; NSMutableArray&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[NSMutableArray copy] =&amp;gt; NSArray
[NSArray mutableCopy] =&amp;gt; NSMutableArray
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;编写拷贝时，需考虑一个问题：应该执行“深拷贝”还是“浅拷贝”？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;深拷贝：&lt;/strong&gt;在拷贝对象自身时，将其底层数据也一并的复制过来。&lt;code class=&quot;highlighter-rouge&quot;&gt;Foundation&lt;/code&gt;框架中所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;collection&lt;/code&gt;类在默认的情况下都执行浅拷贝，也就是说，只拷贝其容器本身，而不复制其中的数据。原因在于：容器内的对象未必都能拷贝，而调用者也未必想在拷贝容器时一并拷贝其中的每一个对象。&lt;/p&gt;

&lt;p&gt;一般情况下，遵循系统框架的模式，对于自定义的类，以浅拷贝的方式实现&lt;code class=&quot;highlighter-rouge&quot;&gt;copyWithZone:&lt;/code&gt;方法，必要的话，也可以增加一个深拷贝的方法。&lt;/p&gt;

&lt;p&gt;例如&lt;code class=&quot;highlighter-rouge&quot;&gt;NSSet&lt;/code&gt;类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)initWithSet:(NSArray *)array copyItems:(BOOL)copyItems;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;若&lt;code class=&quot;highlighter-rouge&quot;&gt;copyItems&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;YES&lt;/code&gt;执行深拷贝。&lt;/p&gt;

&lt;p&gt;例如刚才的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)deepCopy
{
Person *copy = [[[self class] allocWithZone:zone] initWithFirstName:first andLastName:last];

/* 如果有特殊需要，例如保存特定的数据结构 */
copy-&amp;gt;_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES];

return copy;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为没有专门的深拷贝协议，所以具体执行方式有每个类来确定。只需决定自己缩写的类是有需要提供深拷贝方法就可以了。不要假定遵从了&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCopying&lt;/code&gt;协议的对象都会深拷贝。在绝大多数的情况下，都是执行浅拷贝的。如果需要在某个对象上执行深拷贝，那么除非另有说明，否则，要么找到能够找到执行深拷贝的相关方法，要么自己实现相关拷贝方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;若想令自己所写的类具有拷贝功能，则需实现&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCopying&lt;/code&gt;协议。&lt;/li&gt;
  &lt;li&gt;如果自定义的对象分为可变版本与不可变版本，那么就要同时实现&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCopying&lt;/code&gt; &amp;amp;&amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;NSMutableCopying&lt;/code&gt;协议。&lt;/li&gt;
  &lt;li&gt;复制对象时需决定采用深拷贝还是浅拷贝，一般情况下尽量执行浅拷贝。&lt;/li&gt;
  &lt;li&gt;如果所写的对象需要深拷贝，那么可以考虑新增一个专门执行深拷贝的方法。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 26 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/26/%E7%90%86%E8%A7%A3NSCopying%E5%8D%8F%E8%AE%AE/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/26/%E7%90%86%E8%A7%A3NSCopying%E5%8D%8F%E8%AE%AE/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>5分钟带你看完 WWDC 2018</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;一年一度的 WWDC（苹果全球开发者大会）于北京时间 6月5日 凌晨1点开幕。废话不多说，来看看这次WWDC 都有哪些亮点吧!&lt;/p&gt;

&lt;h2 id=&quot;ios-12-和-arkit-20&quot;&gt;iOS 12 和 ARKit 2.0&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;关键词：官方防沉迷最为致命&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ios-12&quot;&gt;iOS 12&lt;/h3&gt;

&lt;p&gt;iOS 12 相较于 iOS 11 并没有太多UI上的变动，刚更新完 bate 版本的 iOS 12，完全感觉不到这是个新系统。&lt;/p&gt;

&lt;p&gt;iOS 12 主要是对安全和性能的优化，iOS 12 在旧设备上的运行速度比 iOS 11更块，程序加载速度快了一倍。（PS：看来苹果并没有放弃旧设备）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.mos.cms.futurecdn.net/RdxhPVv8fAyM6oHsRgF6dH-650-80.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;arkit-20&quot;&gt;ARKit 2.0&lt;/h3&gt;

&lt;p&gt;Apple 与 皮克斯 合作开发了一种用于共享AR内容的新文件格式，新的 AR 格式名为 USDZ。&lt;/p&gt;

&lt;p&gt;作为一个含着金苹果出生的新生儿，USDZ 一开始就得到了 Adobe Creative Cloud （包括 Photoshop CC、InDesign CC、Illustrator CC、Dreamweaver CC、Premiere Pro CC）套件的支持。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-10.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同时，面向开发者的开发套件 ARKit 则升级到了二代，主要提升了面部跟踪、渲染能力、3D 探测和共享体验等能力。&lt;/p&gt;

&lt;p&gt;随后展示了一款名为 Measure 的 App，可使用AR查看物品大小。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.mos.cms.futurecdn.net/4tbGCxGUGsH9VwSLsfMDK5-650-80.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后为了演示新的 AR 能力和效果，苹果请来了乐高的创意总监来捧场。这是一个真实的乐高积木建筑物为基础，最多四个人可以用苹果 AR 应用进行游戏，可以在真实环境中模拟出各种虚拟的形象和建筑。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-9.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-11.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;相册优化&quot;&gt;相册优化&lt;/h3&gt;

&lt;p&gt;iOS 12 的相册将大大提升搜索性能，系统不仅会提出搜索建议，还会帮你按主题整理照片。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-13.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-14.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;siri变得更聪明&quot;&gt;Siri变得更聪明&lt;/h3&gt;

&lt;p&gt;iOS 12 中，苹果为 Siri 提供了更加高效的操作，让它可以操作各个应用内部的功能，并且能在锁屏界面建议用户下一步的行动。&lt;/p&gt;

&lt;p&gt;苹果还发布了一款名为「Shortcuts」的应用，它允许用户自定义 Siri 搜索指令，支持通过拖拽来快速编辑指令，同时还提供了一个指令库供用户下载现成的命令，就像是为 Siri 打造的 Workflow 自动化工具。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/2018-06-04-Artboard.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看到这里，相比熟悉苹果的朋友大概明白了，Siri 的本次改进，很可能是源于它收购的效率神器 Workflow，堪称一个用 Siri 唤醒的 Workflow。&lt;/p&gt;

&lt;h3 id=&quot;原生应用大更新&quot;&gt;原生应用大更新&lt;/h3&gt;

&lt;p&gt;iOS 12 中，不少原生应用都得到了更新。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;iBooks 更名为 &lt;strong&gt;Apple Books&lt;/strong&gt;，采用类似 App Store 的新界面设计。&lt;/li&gt;
  &lt;li&gt;新闻应用（News）在 iPad 上新添加了侧边栏，方便浏览，也突出策划内容。&lt;/li&gt;
  &lt;li&gt;语音备忘录现在支持 iCloud 了&lt;/li&gt;
  &lt;li&gt;股市的界面重构，可以看到股票全天走势，并打通 News 应用，方便看财经新闻；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;carplay-开放了&quot;&gt;CarPlay 开放了&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-21.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CarPlay 变得更加开放了，曾经被苹果狠心抛弃的 Google Maps 和 Google 的干儿子地图 Waze，以及来自东方的神秘力量高德地图成为首批 CarPlay 支持的第三方导航，从此“志玲姐姐为您导航”将可以常伴林肯领航者车主左右，中国梦和美国梦一起实现。&lt;/p&gt;

&lt;h3 id=&quot;防手机沉迷---划重点&quot;&gt;防手机沉迷 - 划重点！&lt;/h3&gt;

&lt;p&gt;本次 iOS 12 的重点就是：&lt;strong&gt;防沉迷！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-25.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;鉴于手机上瘾成为了一个社会议题，今年 Google 和苹果都不约而同地将“防沉迷”加入到了系统更新当中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Do Not Disturb（别吵我）&lt;/strong&gt;功能将关掉手机的视觉通知，在夜深人静想起她或梦见她的时候，来了邮件也不会亮屏刺破夜的静谧和黑暗&lt;/li&gt;
  &lt;li&gt;Deliver Quietly（安静通知）则是将消息推送静默化、不显示在锁屏，也不出声，也不会在 app 右上角标红&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Grouped Notifications（分组通知&lt;/strong&gt;）可以将某一类型的通知归组，微信群聊消息不再有轰炸的感觉&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Reports（应用报告）&lt;/strong&gt;可以用周报告的形式，告诉用户用什么应用最多，哪个应用通知最多，每天起床第一个打开的是什么应用等等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;App Limits（应用限制&lt;/strong&gt;）可以给某个应用规定使用时间，当然这不是强制性的，用户可以突破限制继续“吃鸡”&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Allowances（零用钱？）&lt;/strong&gt; 是家长限制孩子使用应用的新特性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;imessage-和-feactime&quot;&gt;iMessage 和 FeacTime&lt;/h3&gt;

&lt;p&gt;Animoji 新增了 4 个新表情（幽灵，考拉，老虎和霸王龙），用户还可以为自己量身定做 Animoji ，并用到各种场景——这就是全新的 Memoji 技术&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-26.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/2018/06/05/67b6fba3d36bdd7caf09bec94dcb157b.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;iOS 版 &lt;strong&gt;FaceTime&lt;/strong&gt; 迎来了群聊功能，最多支持 32 人同时聊天，成员可以随时加入或离开聊天。聊天界面用瀑布流的形式呈现，正在说话的成员窗口会自动放大。macOS 版 FaceTime 同样也得到了更新。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/2018-06-04-Screen%20Shot%202018-06-05%20at%202.00.58%20AM.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tvos&quot;&gt;tvOS&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;关键词：优化试听体验&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;tvOS 今年的变化比较小，更新主要集中在了影视资源以及细节优化上。&lt;/p&gt;

&lt;p&gt;Apple TV 4K 将支持杜比全景声和杜比视界，让你在家里也能获得电影院般的听觉体验。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/2018-06-04-Screen%20Shot%202018-06-05%20at%202.26.21%20AM.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;watchos-5&quot;&gt;watchOS 5&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;关键词：运动进行到底&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;随着 Apple Watch 成长的，还有它的操作系统 watchOS，这一次 watchOS 升级到了第五代。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-31.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Apple Watch 的功能朝着运动的方向发展，此次 watchOS 5 的更新，也以运动为主。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-35.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;watchOS 5 的一个小惊喜是让 Apple Watch 成为了对讲机，这个应用名为 Walkie Talkie（对讲机）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-38.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Apple Watch 早就支持了 Apple Pay，不过在通知上，Apple Watch 显然可以做得更多，比如值机和给滴滴师傅付款评分，手表不再只是个通知器，也能做些轻交互。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-51.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有 Apple Watch 可以浏览网页了~&lt;/p&gt;

&lt;h2 id=&quot;macos-mojave&quot;&gt;macOS Mojave&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;关键词：夜间模式、全新的App Store&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/2018-06-04-macOS01.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于大多数人来说，macOS 更新最大的悬念，是新系统叫什么名字。&lt;/p&gt;

&lt;p&gt;答案是：&lt;strong&gt;macOS Mojave&lt;/strong&gt;，Mojave 中译名是莫哈韦沙漠，位于在美国加利福尼亚西南，出于洛杉矶和拉斯维加斯之间。&lt;/p&gt;

&lt;p&gt;在 Mojave 这版系统中，苹果加入了一套适应暗光环境下使用的夜间主题，并对 Mac App Store 的交互界面进行了重塑，整个系统的改变甚至连库克都称为是苹果的一次 “巨大的跨越”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-89.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;夜间模式--动态桌面&quot;&gt;夜间模式 / 动态桌面&lt;/h3&gt;

&lt;p&gt;不少用户会在暗光环境下使用电脑，即便是将屏幕亮度调到最低，也难免会因为白底色为主的主题而感到刺眼。在这次更新中，macOS Mojave 新增加了一套暗色主题，不同于目前将菜单和程序栏调成暗色的选项，新系统上的是一套全局暗色主题，即便是在文件夹、应用里都是以黑色为主色呈现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-63.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外，系统可根据时间变化对桌面进行自动调整，日间使用时系统为正常主题；夜间使用时系统则自动切换至暗色模式主题。此时，台下的开发者们爆发出了一阵欢呼，大概是这个主题能够提升程序员朋友夜间加班的幸福感吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-63.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;智能分类&quot;&gt;智能分类&lt;/h3&gt;

&lt;p&gt;macOS 会跟据文件类型和标签对桌面的文件进行自动分类整理，从此再也不用担心满桌面都是文件了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-82.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/2018-06-04-macOS04.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;快速查看升级&quot;&gt;快速查看升级&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-92.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;访达在这次系统上的更新并不多，只是针对图片查看增添了 “图库视图” 功能。通过 “图库视图”，用户可更加便捷快速地浏览到访达文件夹内的图片内容，与此同时功能内部也内置了图片元数据显示窗，用户可以借助数据窗口了解到图片的相关详情，并且可对图片进行快速编辑操作。&lt;/p&gt;

&lt;h3 id=&quot;截图录屏操作---类似ios&quot;&gt;截图/录屏操作 - 类似iOS&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-93.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此次 macOS Mojave 加入了 “系统级” 的截屏功能，用户也可以在截屏后对截屏图片进行简单的标记。不过实际上，目前不少社交软件其实都已经具备了截图 + 标记的相关功能，且在体验上也相当不错。&lt;/p&gt;

&lt;h3 id=&quot;安全权限&quot;&gt;安全权限&lt;/h3&gt;

&lt;p&gt;当我们在 iOS 系统上打开刚下载的应用程序时，系统会弹出弹窗，提示是否允许程序访问用户信息和手机硬件。而这次苹果也将相关的安全控制策略从 iOS “搬” 到了 macOS 上，当用户打开某个网址或程序时，系统会弹出 “是否允许访问” 的弹窗以获得用户批准。这也可能是为了呼应最近越发严格的隐私政策。&lt;/p&gt;

&lt;h3 id=&quot;在-macos-上运行的几款-ios-程序&quot;&gt;在 macOS 上运行的几款 iOS 程序&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-84.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将 iOS 的应用程序搬到 macOS 上运行是不少玩家曾经有过的想法。此次苹果在新版的 macOS 系统上加入了 iOS 端的新闻、股市、家、语音备忘录四个程序，用户可以在桌面系统上通过这几款应用阅读新闻、控制家庭设备等等。&lt;/p&gt;

&lt;p&gt;在发布会的最后，苹果否认了将对 iOS 和 macOS 进行合并的传闻，但考虑到 iOS 平台有非常庞大的应用数量，他们也希望其中的部分应用能来到 macOS。于是苹果在发布会上为大家提前预览了一个准备多年的项目，macOS 将可以使用 iOS 的 UIKit 框架进行开发，以降低开发多平台应用的成本。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/2018-06-04-Screen%20Shot%202018-06-05%20at%203.08.05%20AM.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比如这次 macOS Mojave 中新增的 4 款应用——News、股票、语音备忘录、家庭——均采用了这种新技术。&lt;/p&gt;

&lt;h3 id=&quot;全新的-mac-app-store&quot;&gt;全新的 Mac App Store&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/2018-06-04-macOS09.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 iOS 11 对 Mac App Store 进行了重新设计后，macOS Mojave 也迎来了全新设计的 Mac App Store。新版拥有与 iOS 上 App Store 类似的发现页，里面能看到每日编辑推荐和一些 App 的使用技巧。进入 App 页面后，你可以看到视频预览和与 iOS 类似的评分系统。为了方便用户评分，新版 macOS 还加入了和 iOS 一样的 App 内打分功能。此外，苹果还宣布包括 Office 365 和 Adobe Lightroom CC 在内的一批重量级 App 将在今年稍后登录 Mac App Store。&lt;/p&gt;

&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;是的，这次的 WWDC 只有软件，没有新的电子设备发布，没有新 iPad Pro、没有 iPhone SE2、没有带八代酷睿的新 MacBook，唯一能和“硬件”沾上边的就是一个新的彩虹表带。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-56.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;时至今日，苹果生态已经日趋完善了，大概苹果的产品经理们也想不出什么石破天惊的功能让大家 wow 一声了，有的只是细节层面的改进。作为看客和用户，也只能接受这样的现实了。&lt;/p&gt;

&lt;p&gt;对了，那个可以四个人一起玩的乐高积木和 AR 应用，倒是可以考虑买来玩一下，不要一边说没有新东西，一边又对新东西视而不见。&lt;/p&gt;

&lt;p&gt;对于 iOS 开发者来说，macOS 将可以使用 iOS 的 UIKit 框架进行开发是一个值得关注的点。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2018/101/&quot;&gt;WWDC 2018 Keynote&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.techradar.com/news/apple-wwdc-2018-keynote&quot;&gt;Apple WWDC 2018: what’s new? All the announcements from the keynote&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ifanr.com/1043270&quot;&gt;iOS 加入「防沉迷」，macOS 有了暗色主题，今年的 WWDC 重点都在系统上&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://sspai.com/post/44816&quot;&gt;苹果 WWDC 2018：最全总结看这里，不错过任何重点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 05 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/05/5%E5%88%86%E9%92%9F%E5%B8%A6%E4%BD%A0%E7%9C%8B%E5%AE%8C-WWDC-2018/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/05/5%E5%88%86%E9%92%9F%E5%B8%A6%E4%BD%A0%E7%9C%8B%E5%AE%8C-WWDC-2018/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>判断当前viewcontroller是push还是present的方式显示</title>
        <description>&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;presentviewcontroller&lt;/code&gt;的方式显示的&lt;code class=&quot;highlighter-rouge&quot;&gt;viewcontroller&lt;/code&gt;不会存入&lt;code class=&quot;highlighter-rouge&quot;&gt;self.navigationController.viewControllers&lt;/code&gt;数组中。而通过push方式显示的&lt;code class=&quot;highlighter-rouge&quot;&gt;viewcontroller&lt;/code&gt;会存在该数组的最后。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;NSArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewcontrollers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;navigationController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewControllers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    
    
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewcontrollers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewcontrollers&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;objectAtIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewcontrollers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;    
        &lt;span class=&quot;c1&quot;&gt;//push方式    &lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;navigationController&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;popViewControllerAnimated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;YES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;    
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;    
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;    
    &lt;span class=&quot;c1&quot;&gt;//present方式    &lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;navigationController&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;dismissViewControllerAnimated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;YES&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 14 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/14/%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8Dviewcontroller%E6%98%AFpush%E8%BF%98%E6%98%AFpresent%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%BE%E7%A4%BA/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/14/%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8Dviewcontroller%E6%98%AFpush%E8%BF%98%E6%98%AFpresent%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%BE%E7%A4%BA/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
