<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Japho Blog</title>
    <description>The shortest answer is doing.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 05 Nov 2018 15:45:33 +0800</pubDate>
    <lastBuildDate>Mon, 05 Nov 2018 15:45:33 +0800</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>理解“块”这一概念</title>
        <description>&lt;h3 id=&quot;块的基础知识&quot;&gt;块的基础知识&lt;/h3&gt;

&lt;p&gt;块与函数类似，只不过是直接定义在另一个函数里的，和定义它的那个函数共享同一个范围内的东西。用&lt;code class=&quot;highlighter-rouge&quot;&gt;“^”&lt;/code&gt;符号表示。简单的块：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;^{
//Block implementation here
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;块其实就是个值，而且自有其相关类型。与&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;或Objective-C对象一样，可以把块赋值给变量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void (^someBlock)() = ^{
//Block implementation here
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;定义了一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;someBlock&lt;/code&gt;的变量。块类型的语法结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return_type (^block_name)(parameters)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;例如：定义一个块，返回&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;值，并且接受两个&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;参数返回和：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int (^addBlock)(int a, int b) = ^(int a, int b){
return a + b;
}
int add = addBlock(2, 5); // add = 7;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;块的强大之处：在声明的范围内，所有变量都可以为其所捕获。也就是说，那个范围里的全部变量，在块里依然可以使用。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int additional = 5;
int (^addBlock)(int a, int b) = ^(int a, int b){
return a + b + additional;
}
int add = addBlock(2, 5); // add = 7;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;默认情况下，为块所捕获的变量，是不可以在块里修改的。编译器会报错，声明变量时加上&lt;code class=&quot;highlighter-rouge&quot;&gt;__block&lt;/code&gt;修饰符，这样就可以在块内修改了。&lt;/p&gt;

&lt;p&gt;如果块所捕获的变量时对象类型，那么就会自动保留它。系统在释放这个块的时候，也会将其一并释放。实际上，在其他Objective-C对象所能响应的选择子中，有很多是块也可以响应的。而重要的在于块和其他对象一样，也有引用计数，当最后一个指向块的引用移走之后，块就会回收了。回收时，也会释放块所捕获的变量。&lt;/p&gt;

&lt;p&gt;如果将块定义在Objective-C类的实例方法中，除了可以访问类的所有实例变量之外，还可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;变量。块总可以修改实例变量，所以在声明时无须加&lt;code class=&quot;highlighter-rouge&quot;&gt;__block&lt;/code&gt;。不过如果是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt;方法捕获了实例变量，那么也会把&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;变量一并捕获，因为实例变量是与&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;所指代的实例关联在一起的。（此时要注意循环引用）&lt;/p&gt;

&lt;h3 id=&quot;块的内部结构&quot;&gt;块的内部结构&lt;/h3&gt;

&lt;p&gt;块本身也是对象，在存放块对象的内存区域中，首个变量是只想&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;对象的指针，该指针叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;isa&lt;/code&gt;指针。在内存布局中，最重要的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;invoke&lt;/code&gt;变量，这是个函数指针，指向块的实现代码。函数原型至少要接受一个&lt;code class=&quot;highlighter-rouge&quot;&gt;void*&lt;/code&gt;类型的参数，此参数代表块。&lt;code class=&quot;highlighter-rouge&quot;&gt;descriptor&lt;/code&gt;是指向结构体的指针，每个块里都包含此结构体，其中声明了块对象的总体大小，还声明了&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;dispose&lt;/code&gt;两个辅助函数所对应的函数指针。块还会把它所捕获的所有变量都拷贝一份，这些靠背放在了&lt;code class=&quot;highlighter-rouge&quot;&gt;descriptor&lt;/code&gt;之后，捕获多少变量就要占据多少内存空间，这里拷贝的不是对象本身，而是指向这些对象的指针变量。&lt;/p&gt;

&lt;h3 id=&quot;全局块栈块堆块&quot;&gt;全局块、栈块、堆块&lt;/h3&gt;

&lt;p&gt;定义块的时候，其所占用的区域是分配在栈中的。就是说，块只在定义它的那个范围内有效。&lt;/p&gt;

&lt;p&gt;编译器会给每个快分配好栈内存，然而等离开了相应的范围之后，编译器有可能把分配给块的内存复写掉。运行起来时而正确时而错误。为解决此问题，给每块对象发送&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;消息。这样就可以把块从栈复制到堆中。拷贝之后的块可在定义它的范围之外使用，而且一旦复制到堆上，块就成了带引用计数的对象了。后续的复制不会真的执行复制，只是递增独享的引用计数。&lt;/p&gt;

&lt;p&gt;除了栈块、堆块外，还有全局块。这种快不会捕捉任何状态（比如外围变量），运行时也无须有状态来参与。块所使用的整个内存区域，在编译期就完全确定了。因此，全局块可声明在全局内存里。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;块是C、C++、Objective-C中的词法闭包。&lt;/li&gt;
  &lt;li&gt;块接受参数，也可返回值。&lt;/li&gt;
  &lt;li&gt;块可以飞陪在栈或内存上，也可以是全局的。分配在栈上的块可拷贝到堆里，这样和标准的Objective-C对象一样，具备引用计数。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 12 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/12/%E7%90%86%E8%A7%A3-%E5%9D%97-%E8%BF%99%E4%B8%80%E6%A6%82%E5%BF%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/12/%E7%90%86%E8%A7%A3-%E5%9D%97-%E8%BF%99%E4%B8%80%E6%A6%82%E5%BF%B5/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>以“自动释放池块”降低内存峰值</title>
        <description>&lt;p&gt;释放对象有两种方式：一种是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;方法，使其保留计数立即递减；另一种是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt;方法，将其加入到“自动释放池”中。自动释放池用于存放那些需要稍后再某个时刻释放的对象。清空（&lt;code class=&quot;highlighter-rouge&quot;&gt;drain&lt;/code&gt;）自动释放池时，系统会向其中的对象发送&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;信息。&lt;/p&gt;

&lt;p&gt;一般情况下无需担心自动释放池的创建问题。系统会自动创建一些线程，例如主线程，或GCD机制中的线程，这些线程默认都是自动释放池的，每次执行事件循环（&lt;code class=&quot;highlighter-rouge&quot;&gt;event loop&lt;/code&gt;）时，就会将其清空。因此，不需要自己创建“自动释放池块”。通常只有一个地方需要创建自动释放池，那就是在main函数中。用自动释放池来包裹应用程序的主入口点。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main(int argc,  char *argv[])
{
@autoreleasepool{
return UIApplicationMain(argc,  argv,  nil,  @&quot;AppDelegate&quot;);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果不写这个块的话，那么由&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplicationMain&lt;/code&gt;函数所释放的那些对象，就没有自动释放池可以容纳了，系统会警告。这个池可以理解成最外围捕捉全部自动释放对象所用的池。&lt;/p&gt;

&lt;p&gt;自动释放池于左花括号处创建，并于右花括号处自动清空。位于自动释放池范围内的对象，将在此范围末尾处收到&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;消息。自动释放池可以嵌套。系统在自动释放对象时，会把它放到最内层的池里。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@autoreleasepool{
NSString *string =  [NSString  stringWithFormat:@&quot;1  =  %i&quot;,  1];

@autoreleasepool{
NSNumber  *number =  [NSNumber  numberWithInt:1];
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这两个对象都由类的工厂方法创建，这样创建出来的对象会自动释放。&lt;code class=&quot;highlighter-rouge&quot;&gt;NSString&lt;/code&gt;对象在外围的自动释放池中，&lt;code class=&quot;highlighter-rouge&quot;&gt;NSNumber&lt;/code&gt;在里层的自动释放池中。将自动释放池嵌套使用的好处是，可以借此控制应用程序的内存峰值，使其不致过高。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (int i =  0;i &amp;lt; 10000;  i++)
{
[self doSomethingWithInt:i];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果方法&lt;code class=&quot;highlighter-rouge&quot;&gt;doSomethingWithInt:&lt;/code&gt;要创建临时对象，那么这些对象很有可能放在自动释放池里，但是即便这些对象在调用完方法之后就不再使用了，他们也依然处于存活状态，因为目前还在自动释放池里。等系统线程执行下一次事件循环时才会清空。这意味着在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;循环时，会持续有新的对象创建出来，并加入自动释放池中。所有这种对象都要等for循环执行完毕才会释放，这样一来，在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;循环时，应用程序所占内存量就会持续上涨，而等到所有临时对象都释放后，内存用量又会突然下降。&lt;/p&gt;

&lt;p&gt;这里增加一个自动释放池即可解决此问题。把循环内的代码包裹在“自动释放池块”中，那么在循环中自动释放的对象就会放在这个池，而不是线程的主池里面。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (int i =  0;i &amp;lt; 10000;  i++)
{
@autoreleasepool{
[self doSomethingWithInt:i];
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;加上这个自动释放池之后，执行循环时内存峰值就会降低。内存峰值：应用程序在某个特定的时间段内的最大内存用量。新增自动释放吃块可以减少峰值，是因为系统会在块的末位把某些对象回收掉。&lt;/p&gt;

&lt;p&gt;自动释放池机制就像“栈”一样。系统创建好自动释放池之后，就将其推入栈中，而清空自动释放池，则相当于将其从栈中弹出。在对象上执行自动释放操作，就等于将其放入栈顶的那个池里。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自动释放池排布在栈中，对象收到&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt;消息后，系统将其放入最顶端的池里。&lt;/li&gt;
  &lt;li&gt;合理运用自动释放池，可降低应用程序的内存峰值。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@autoreleasepool&lt;/code&gt;这种新写法大能创建出更为轻便的自动释放池。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 10 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/10/%E4%BB%A5-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E5%9D%97-%E9%99%8D%E4%BD%8E%E5%86%85%E5%AD%98%E5%B3%B0%E5%80%BC/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/10/%E4%BB%A5-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E5%9D%97-%E9%99%8D%E4%BD%8E%E5%86%85%E5%AD%98%E5%B3%B0%E5%80%BC/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>以弱引用避免保留环</title>
        <description>&lt;p&gt;对象中经常出现一种情况，就是几个对象都以某种方式互相引用，从而形成了“环”。这种情况通常会造成内存泄漏，因为最后没有别的东西会引用环中的对象。这样的话，环里的对象就无法为外界所访问了，但对象间尚有引用，这使得他们都能够存活下去，而不会被系统回收。&lt;/p&gt;

&lt;p&gt;循环引用会导致内存泄漏，从一开始编码时，就应该注意别出现循环引用。&lt;/p&gt;

&lt;p&gt;避免循环引用的最佳方式就是使用弱引用。这种引用通常来表示“非拥有关系”。将属性声明为&lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_unretained&lt;/code&gt;即可。&lt;/p&gt;

&lt;p&gt;属性中的&lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_unretained&lt;/code&gt;表示，属性值可能不安全，而且不归此实例拥有。如果系统已经属性所指的那个对象回收了，那么再其上调用方法可能会使应用崩溃。用&lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_unretained&lt;/code&gt;修饰的属性，其语义同&lt;code class=&quot;highlighter-rouge&quot;&gt;assign&lt;/code&gt;等价，然后assign通常只修饰“基本类型”，&lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_unretained&lt;/code&gt;多用于对象类型。
ARC中还有一种弱引用特质，就是weak，他与&lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_unretained&lt;/code&gt;的作用完全相同。然而，系统把属性回收，属性值就会自动设置为nil。
如果对象已经被回收，引用他的实例仍然存活，这就是编程错误。使用weak而非&lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_unretained&lt;/code&gt;引用可令代码更加安全。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将某些引用设为weak，可避免出现“循环引用”&lt;/li&gt;
  &lt;li&gt;weak引用可以自动清空，也可不自动清空。自动清空是随着ARC而引入的新特性，由运行期系统实现。在具备自动清空的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 06 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/06/%E4%BB%A5%E5%BC%B1%E5%BC%95%E7%94%A8%E9%81%BF%E5%85%8D%E4%BF%9D%E7%95%99%E7%8E%AF/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/06/%E4%BB%A5%E5%BC%B1%E5%BC%95%E7%94%A8%E9%81%BF%E5%85%8D%E4%BF%9D%E7%95%99%E7%8E%AF/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>编写“异常安全代码”时留意内存管理问题</title>
        <description>&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;try&lt;/code&gt;块中，如果保留了某个对象，然后在释放之前抛出了异常，那么，除非&lt;code class=&quot;highlighter-rouge&quot;&gt;catch&lt;/code&gt;块能够处理此问题，否则对象所占内存将泄露。&lt;/p&gt;

&lt;p&gt;虽说默认情况下不开启，但是ARC依然能生成这种安全处理异常所用的附加代码。&lt;code class=&quot;highlighter-rouge&quot;&gt;-fobjc-arc-exceptions&lt;/code&gt;这个编译器标志用来开启此功能。默认不开启是因为，Objective-C代码中，只有当应用程序必须因异常终止时才会跑出异常。如果应用终止，是否会发生内存泄露就无关紧要了。&lt;/p&gt;

&lt;p&gt;如果手动管理引用计数，而且必须捕获异常，那么要设法保证所编写代码能把对象正确清理干净。若使用ARC而且必须捕获异常，则需要打开编译器的&lt;code class=&quot;highlighter-rouge&quot;&gt;-fobjc-arc-exceptions&lt;/code&gt;标志。但是，重要的是，在发现大量异常捕获操作时，应该考虑重构代码，使用NSError错误信息传递法来取代异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;捕获异常时，一定要注意将&lt;code class=&quot;highlighter-rouge&quot;&gt;try&lt;/code&gt;块内所创立的对象清理干净。&lt;/li&gt;
  &lt;li&gt;在默认情况下，ARC不会生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 05 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/05/%E7%BC%96%E5%86%99-%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81-%E6%97%B6%E7%95%99%E6%84%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/05/%E7%BC%96%E5%86%99-%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81-%E6%97%B6%E7%95%99%E6%84%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>通过协议提供匿名对象</title>
        <description>&lt;p&gt;协议定义了一系列方法，遵从此协议的对象应该实现他们。于是，我们可以用协议把自己所写的API中的实现细节隐藏起来，将返回对象设计为遵从此协议的纯id类型。这样，想要隐藏的类名就不会出现在API之中，若接口背后有多个不同的类，而你不想指明具体使用哪个类，那么可以考虑使用这个方法，因为有时候这些类可能会变，有时候他们无法容纳于标准的类集成体系中，因而不能以某个公共基类来统一表示。&lt;/p&gt;

&lt;p&gt;这个概念通常称为“&lt;strong&gt;匿名对象&lt;/strong&gt;”，例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property (nonatomic, weak) id&amp;lt;PersonDelegate&amp;gt; delegate;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于该属性的类型是 &lt;code class=&quot;highlighter-rouge&quot;&gt;id&amp;lt;PersonDelegate&amp;gt;&lt;/code&gt; ，实际上任何类的对象都能充当这一属性，即便该类不继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;也可以，只要遵循&lt;code class=&quot;highlighter-rouge&quot;&gt;PersonDelegate&lt;/code&gt;协议就可以。对于具备此属性的类来说，&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt;就是“匿名的”。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSDictionary&lt;/code&gt;也可以说明这个概念。字典中，键的标准内存管理语义是“设置时拷贝”，而值的语义是“设置时保留”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)setObject:(id)object forKey:(id&amp;lt;NSCopying&amp;gt;)key;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;键的参数类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;id&amp;lt;NSCopying&amp;gt;&lt;/code&gt;，作为参数值的对象，可以是任何类型。只要遵循NSCopying协议就可以。&lt;/p&gt;

&lt;p&gt;有时候对象类型并不重要，重要的是对象有没有实现某些方法。在这种情况下，也可以用这些“匿名类型”来表达这一概念。即便实现代码总是使用固定的类，还是可能会把它写成遵循某些协议的匿名类型，以表示类型在此处并不重要。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的id类型，协议里规定了对象所应实现的方法。&lt;/li&gt;
  &lt;li&gt;使用匿名对象来隐藏类型名称（或者类名）&lt;/li&gt;
  &lt;li&gt;如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可使用匿名对象来表示。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 16 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/16/%E9%80%9A%E8%BF%87%E5%8D%8F%E8%AE%AE%E6%8F%90%E4%BE%9B%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/16/%E9%80%9A%E8%BF%87%E5%8D%8F%E8%AE%AE%E6%8F%90%E4%BE%9B%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>理解引用计数</title>
        <description>&lt;p&gt;Objective-C语言使用引用技术来管理内存，也就是说，每个对象都有可以递增或递减的计数器。如果想使某个对象继续存活，就递增其引用计数；用完之后，就递减其引用计数，计数变为0时，表示没有人关注这个对象，自然就把他释放了。&lt;/p&gt;

&lt;h3 id=&quot;引用计数工作原理&quot;&gt;引用计数工作原理&lt;/h3&gt;

&lt;p&gt;引用计数的架构下，对象有个计数器，用以表示当前有多少事物想令此对象存活下去，在Objective-C中叫做“引用计数”。&lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;协议中声明了一下三个方法用于操作计数器，以递增或递减引用计数。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;retain&lt;/code&gt; 递增引用计数；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt; 递减引用计数；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt; 待稍后清理“自动释放池”时，再去递减其引用计数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看引用计数的方法叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;retainCount&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;对象在创建出来时，其引用计数至少为1，若想继续存活，则调用&lt;code class=&quot;highlighter-rouge&quot;&gt;retain&lt;/code&gt;方法。要是某部分代码不再调用此对象，不想令其存活，则调用&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt;方法。当引用计数为0时，对象就会被回收。这时，系统会将其占用的内存标记为“可重用”（&lt;code class=&quot;highlighter-rouge&quot;&gt;reuse&lt;/code&gt;）。此时所有指向该对象的引用都变得无效了。&lt;/p&gt;

&lt;p&gt;下列代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableArray *array = [[NSMutableArray alloc] init];
NSNumber *number = [[NSNumber alloc] initWithNumber:1337];
[array addObject:number];
[number release];
//do somthing with array;
[array release];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于上述代码调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;，所以在ARC下无法编译。在&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;中，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt;方法所返回的对象由调用者所有。也就是说，调用者，已通过alloc方法表达了相对该对象继续存活的意愿。这里可以肯定此时引用计数一定大于1。
创建完成后，把&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;加入数组中，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;addObject:&lt;/code&gt;方法时，数组也会在&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;上调用&lt;code class=&quot;highlighter-rouge&quot;&gt;retain&lt;/code&gt;方法，以继续保留此对象。此时，引用计数至少为2。接下来，代码不再需要&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;对象了，于是将其释放，此时引用计数至少为1，这样就不能照常使用&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;变量了。调用&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;之后，已经无法保证所指对象是否仍然存活。不过这里我们知道&lt;code class=&quot;highlighter-rouge&quot;&gt;array&lt;/code&gt;还对&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;存在引用。但是不要假设这一对象一定存活，也就是说，不要编写下列代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableArray *array = [[NSMutableArray alloc] init];
NSNumber *number = [[NSNumber alloc] initWithNumber:1337];
[array addObject:number];
[number release];
NSLog(@&quot;number = %@&quot;,number);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述代码仍可执行，但如果调用&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;之后，基于某种原因，引用计数变为0，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;对象所占有内存也会被回收，这样，再去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog&lt;/code&gt;就可能造成崩溃。这里只是说“可能”，并不是“一定”，因为对象所占有的内存在“解除分配”之后，只是放回“可用内存池”（&lt;code class=&quot;highlighter-rouge&quot;&gt;avaiable pool&lt;/code&gt;）。如果执行&lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog&lt;/code&gt;时尚未覆写对象内存，那么该对象仍然有效，这是程序并不会崩溃，不过过早释放对象而造成的bug将会很难调试。&lt;/p&gt;

&lt;p&gt;为了避免在不经意间使用了无效对象，一般调用完&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;之后都会进行清空指针。这就能保证不会出现可能指向无效指针对象的指针。（悬挂指针）。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSNumber *number = [[NSNumber alloc] initWithNumber:1337];
[array addObject:number];
[number release];
number = nil;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;属性存取方法中的内存管理&quot;&gt;属性存取方法中的内存管理&lt;/h3&gt;

&lt;p&gt;访问属性时，会用到相关实例变量的&lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt;方法及&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;方法。若属性为&lt;code class=&quot;highlighter-rouge&quot;&gt;strong&lt;/code&gt;关系，则设置的属性值会保留，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)setFoo:(id)foo
{
[foo retain];
[_foo release];
_foo = foo;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此方法将保留新值并释放旧值，然后更新实例变量。&lt;/p&gt;

&lt;h3 id=&quot;自动释放池&quot;&gt;自动释放池&lt;/h3&gt;

&lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;releas&lt;/code&gt;e会立刻递减对象的保留计数，有时可能令系统回收此对象，然后有时候改为调用&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt;，此方法会在稍后递减计数，通常是在下一次“事件循环”时递减，不过也可能会更早。
&lt;code class=&quot;highlighter-rouge&quot;&gt;autoreleas&lt;/code&gt;e能延长对象生命周期，使其在跨越方法调用便捷后依然可以存活一段时间。&lt;/p&gt;

&lt;h3 id=&quot;循环引用&quot;&gt;循环引用&lt;/h3&gt;

&lt;p&gt;呈环状互相引用多个对象，这将导致内存泄漏。因为循环中的对象其引用计数不会降为0，对于循环中的每个对象来说，至少还有另外一个对象引用他。通常采用“弱引用”解决，或者从外界命令循环中的某个对象不再保留另外一个对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其引用计数至少为1。若引用计数为正，则对象继续存活，当引用计数降为0时，对象就被销毁了。&lt;/li&gt;
  &lt;li&gt;在对象生命周期中，其余对象通过引用来保留或者释放此对象。保留与释放操作分别会递增及递减引用计数。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 15 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/15/%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/15/%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>以ARC简化引用计数</title>
        <description>&lt;p&gt;使用ARC时，引用计数实际上还是要执行的，只不过保留与释放操作现在是由ARC自动添加的。由于ARC会自动执行&lt;code class=&quot;highlighter-rouge&quot;&gt;retain&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt;等操作，所以直接在ARC下调用这些内存管理方法是非法的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例如以下方法：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;retain&lt;/li&gt;
  &lt;li&gt;release&lt;/li&gt;
  &lt;li&gt;autorelease&lt;/li&gt;
  &lt;li&gt;dealloc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;直接调用这些方法会产生编译错误。&lt;/p&gt;

&lt;h3 id=&quot;使用arc时必须遵循的方法命名规则&quot;&gt;使用ARC时必须遵循的方法命名规则&lt;/h3&gt;

&lt;p&gt;若以以下词语开头，其返回的对象归调用者所有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;alloc&lt;/li&gt;
  &lt;li&gt;new&lt;/li&gt;
  &lt;li&gt;copy&lt;/li&gt;
  &lt;li&gt;mutableCopy&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;归调用者所有的意思是：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;调用上述四种方法的那段代码要负责释放方法所返回的对象。也就是说，这些对象的保留计数是正值，而调用了这四种方法的那段代码要将其中一次保留操作抵消掉。&lt;/p&gt;

  &lt;p&gt;除了自动调用“保留”与“释放”的方法之外，使用ARC时，他可以在编译期把能够相互抵消的&lt;code class=&quot;highlighter-rouge&quot;&gt;retain&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;auitorelease&lt;/code&gt;操作约简。如果发现在同一个对象上执行了多次“保留”与“释放”操作，那么ARC有时也可以成对的移除这两个操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;变量的内存管理语义&quot;&gt;变量的内存管理语义&lt;/h3&gt;

&lt;p&gt;ARC会用一种安全的方式来设置：先保留新值，再释放旧值，最后设置实例变量。使用ARC之后，无需考虑这种“边界情况”。&lt;/p&gt;

&lt;p&gt;在应用程序中，可用下列修饰符来改变局部变量与实例变量的语义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__strong&lt;/code&gt;：默认语义，保留这个值&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__unsafe_unretained&lt;/code&gt;：不保留这个值，（可能不安全，下次使用变量时，其对象可能已经被回收）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt;：不保留这个值，但是变量可以安全使用，因为如果系统把这个对象回收了，那么变量也会被自动清空。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__autoreleasing&lt;/code&gt;：把对象“按引用传递”给方法时，使用这个特殊的修饰符，这个值在方法返回时自动释放。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如：想令实力变脸的语义与不使用ARC时相同，可以运用&lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;__unsafe_unretained&lt;/code&gt;修饰符。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface EOCClass  :  NSObject
{
id __weak _weakObject;
id __unsafe_unretained  _unsafeUnretainedObject;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;arc如何清理实例变量&quot;&gt;ARC如何清理实例变量&lt;/h3&gt;

&lt;p&gt;非Objective-C的对象，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;CoreFoundation&lt;/code&gt;框架中的对象，或是由&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc()&lt;/code&gt;分配在堆中的内存，这时仍然需要手动清理。这里调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;方法时，并不需要调用超类的&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;，在ARC下不能直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;。ARC会自动生成代码并运行此方法，生成的代码中会自动调用超类的&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc()&lt;/code&gt;方法。可以这么写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-  (void)dealloc
{
CFRelease(_coreFoundationObject);
free(_heapAllocatedMemoryBlob);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;覆写内存管理方法&quot;&gt;覆写内存管理方法&lt;/h3&gt;

&lt;p&gt;不使用ARC时，可以覆写内存管理方法，但是在ARC环境下，不能这么做，因为会干扰ARC分析对象生命周期的工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有ARC之后，程序员就无须担心内存管理问题了。使用ARC来编程，可省去勒种的许多“样板代码”。&lt;/li&gt;
  &lt;li&gt;ARC管理对象生命周期的办法基本上就是：在合适的地方插入“保留”及“释放”操作。在ARC环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手动执行“保留”及“释放”操作。&lt;/li&gt;
  &lt;li&gt;由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC将此确定为开发者必须遵守的规定。
ARC只负责管理Objective-C对象的内存。&lt;code class=&quot;highlighter-rouge&quot;&gt;CoreFoundation&lt;/code&gt;对象不归ARC管理，开发者需要在合适的时间调用&lt;code class=&quot;highlighter-rouge&quot;&gt;CFRetain&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;CFRelease&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 10 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/10/%E4%BB%A5ARC%E7%AE%80%E5%8C%96%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/10/%E4%BB%A5ARC%E7%AE%80%E5%8C%96%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>在dealloc方法中只释放引用并解除监听</title>
        <description>&lt;p&gt;对象经历生命周期后，就会被系统回收，这时就会执行&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;方法。在每个对象的生命周期内，此方法只执行一次。不应该自己调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;方法，运行期系统会在适当的时候调用他，而且一旦调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;之后，对象就不在有效了，后续调用的方法均是无效的。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;方法中主要是释放对象所拥有的引用，把所有的Objective-C对象都释放掉，ARC会在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;中自动添加这些释放代码。对象所拥有的其他非Objective-C对象也要释放，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;CoreFoundation&lt;/code&gt;对象就必须手动进行释放，因为他是基于C的API生成的。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;方法中，通常还需要将原来配置过的监听方法都清理掉。如果用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSNotificationCenter&lt;/code&gt;给对象注册了某种通知，那么一般应该在这里注销，这样，通知系统就不会再把通知发送给回收后的对象了，如果还发送通知，则必然会引起程序崩溃。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dealloc
{
CFRelease(coreFoundationObject);
[[NSNotificationCenter  defaultCenter]  removeObserver:self];
/*
**    如果非ARC情况下，还需调用
[super dealloc];
*/
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;方法的那个线程会执行“最终的释放操作”，令对象的保留计数降为0，而某些方法必须在特定的线程中调用（主线程）。若在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;调用了哪些方法，则无法保证当前这个线程就是那些方法所需的线程。通过正常的代码编写方式，无论如何都无法保证其会安全运行在正确的线程上，因为对象正处于“正在回收的状态”，为了指明此状况，运行期系统已经改动了对象的内部数据结构。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;里也不要调用属性的&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt;方法，因为这些方法可能会被重写，并与其中做了一些无法在回收阶段安全执行的操作。此外，属性可能处于“键值观察”机制的监控下，该属性的观察者可能会在属性值改变时“保留”或者使用这个即将回收的对象，这会令程序状态失调，导致一些莫名其妙的错误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;方法里，应该做的事情就是释放指向其他对象的引用，并取消原来注册的&lt;code class=&quot;highlighter-rouge&quot;&gt;KVO&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;NSNotificationCenter&lt;/code&gt;等通知，不要做其他事情。&lt;/li&gt;
  &lt;li&gt;如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放这种资源。这样的类要和其使用者的约定：在用完资源之后必须调用&lt;code class=&quot;highlighter-rouge&quot;&gt;close&lt;/code&gt;方法。&lt;/li&gt;
  &lt;li&gt;执行异步任务的方法不应该在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;里调用，只能在正常状态下执行的那些方法也不应该在&lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;里调用，因为此时对象已经处于正在回收的状态了。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/02/%E5%9C%A8dealloc%E6%96%B9%E6%B3%95%E4%B8%AD%E5%8F%AA%E9%87%8A%E6%94%BE%E5%BC%95%E7%94%A8%E5%B9%B6%E8%A7%A3%E9%99%A4%E7%9B%91%E5%90%AC/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/02/%E5%9C%A8dealloc%E6%96%B9%E6%B3%95%E4%B8%AD%E5%8F%AA%E9%87%8A%E6%94%BE%E5%BC%95%E7%94%A8%E5%B9%B6%E8%A7%A3%E9%99%A4%E7%9B%91%E5%90%AC/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>勿在分类中声明属性</title>
        <description>&lt;p&gt;尽管在技术上说，分类中可以声明属性，但是还是要尽量避免这种做法。因为，分类无法向类中新增实例变量，因此，他们无法把实现属性所需的实例变量合成出来。这时，需要在分类中为该属性实现&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;  &amp;amp;&amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt;方法，此时，可将存取方法生命为&lt;code class=&quot;highlighter-rouge&quot;&gt;@dynamic&lt;/code&gt;，就是说，这些方法在运行期再去提供，编译器目前是看不到的。&lt;/p&gt;

&lt;p&gt;利用关联对象解决这个问题：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;objc/runtime.h&amp;gt;

static const char *propertyKey =  &quot;porpertyKey&quot;;

@implementation Person

-  (NSArray  *)friends
{
return objc_getAssociatedObject(self,  porpertyKey);
}

-  (void)setFriends:(NSArray  *)friends
{
objc_setAssociatedObject(self,  porpertyKey,  firends,  OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种方法在技术上可行，但是并不太理想，要把相似的代码写很多遍，而且在内存管理上容易出现错误。例如在为属性实现存取方法时，经常忘记遵从内存管理语义，而且修改属性特质（&lt;code class=&quot;highlighter-rouge&quot;&gt;attribute&lt;/code&gt;）时，也不能忘记修改存取方法。这里还要考虑可变对象的问题，是否传进一个不可变对象，需要生成一个可变对象的问题。&lt;/p&gt;

&lt;p&gt;所以应当把分类理解成一种手段，目的在于扩展类的功能，而非封装数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;把封装数据所用的全部属性都定义在类的主接口里。&lt;/li&gt;
  &lt;li&gt;在“&lt;code class=&quot;highlighter-rouge&quot;&gt;class-continuation&lt;/code&gt;分类”之外的其他分类中，可以定义存取方法，但是尽量不要定义属性。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 01 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/01/%E5%8B%BF%E5%9C%A8%E5%88%86%E7%B1%BB%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%B1%9E%E6%80%A7/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/01/%E5%8B%BF%E5%9C%A8%E5%88%86%E7%B1%BB%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%B1%9E%E6%80%A7/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>编码习惯问题</title>
        <description>&lt;h2 id=&quot;将类的实现代码分散到便于管理的数个分类中&quot;&gt;将类的实现代码分散到便于管理的数个分类中&lt;/h2&gt;

&lt;p&gt;当类中方法及实现过多的时候，可以考虑用Objective-C的“分类”机制，把代码按逻辑划分到几个分区中。通过分类机制，可以把类代码分成很多个易于管理的小块，以便单独检视。此外，使用分类还有一个原因，就是便于调试。对于某个分类中的所有方法来说，分类名称都会出现在其符号中，例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- [Person(FriendShip)  addFriend:]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编写程序库时，可以考虑创建&lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;分类，经常会遇到一些方法，这些方法不是公共的API，但却非常适合在程序库内部使用，此时应该创建爱你&lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;分类，如果程序中某些地方要用到这些方法，就引入这个分类文件。二分类的头文件不随程序库一并公开，于是，该代码库的使用者不会知晓库里还有这些私有方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用分类机制把勒种的实现代码划分成易于管理的小块。&lt;/li&gt;
  &lt;li&gt;将应该视为“私有”的方法归入private分类中，以隐藏实现细节。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总是为第三方类的分类名称加前缀&quot;&gt;总是为第三方类的分类名称加前缀&lt;/h2&gt;

&lt;p&gt;分类机制通常用于向无源码的既有类中添加新功能，但在使用时会存在问题：分类中的方法是直接添加在类中的，将分类方法加入类中这一操作是在运行期系统加载分类时完成的。运行时系统会把分类中所实现的每个方法都加入类的方法列表中，如果类中本来就存在这个方法，那么就会产生覆盖，若发生多次覆盖，则以最后一次为准。&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface NSString  (ABC_HTTP)

- (NSString  *)abc_urlEncodedString;

- (NSString  *)abc_urlDecodedString;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;向第三方类中添加分类时，总应给其名称加上专用前缀。&lt;/li&gt;
  &lt;li&gt;向第三方类中添加分类时，总应给其的方法加上专用前缀。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用class-continuation分类隐藏实现细节&quot;&gt;使用“class-continuation分类”隐藏实现细节&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;class-continuation&lt;/code&gt;分类向类中新增实例变量。&lt;/li&gt;
  &lt;li&gt;如果某属性在主接口中声明为“只读”，而类内部又要用&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;方法修改次数性，那么就在“&lt;code class=&quot;highlighter-rouge&quot;&gt;class-continuation&lt;/code&gt;分类”中将其扩展为“可读写”。&lt;/li&gt;
  &lt;li&gt;把私有方法的原型声明在“&lt;code class=&quot;highlighter-rouge&quot;&gt;class-continuation&lt;/code&gt;分类”中。&lt;/li&gt;
  &lt;li&gt;若想使用类所遵循的协议而不为人所知，则可于“&lt;code class=&quot;highlighter-rouge&quot;&gt;class-continuation&lt;/code&gt;分类”中声明。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;用僵尸对象调试内存管理问题&quot;&gt;用“僵尸对象”调试内存管理问题&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;系统在回收对象时，可以不将其真正的回收，而是把它转化为僵尸对象。通过环境变量&lt;code class=&quot;highlighter-rouge&quot;&gt;NSZombieEnabled&lt;/code&gt;可开启此功能。&lt;/li&gt;
  &lt;li&gt;系统会修改对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;isa&lt;/code&gt;指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接受者的消息，然后终止应用程序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;不要使用retaincount&quot;&gt;不要使用retainCount&lt;/h2&gt;

&lt;p&gt;ARC已经将此方法废弃了，在ARC中调用此方法，编译器会报错。&lt;/p&gt;

&lt;p&gt;此方法无用原因：他返回的引用计数只是某个给定时间点上的值，该方法并未考虑到系统会稍后吧自动释放池清空，因为不会将后续的释放操作从返回值里减去。所以这个值未必能真实的反映实际的保留计数。
我们不应该总是依赖保留计数的具体值来编码。即便是只为了调试，此方法也不是很有用。由于对象可能处在自动释放池中，所以其保留计数未必如想象中精确。而且其他程序库也有可能自行保留或释放对象，这都会扰乱保留计数的具体取值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对象的保留计数看似有用，实则不然，因为任何给定时间点上的“绝对保留计数”都无法反映对象生命期的全貌。&lt;/li&gt;
  &lt;li&gt;引入ARC之后，retainCount方法就正式废止了，在ARC下调用该方法会导致编译器报错。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;为常用的块类型创建typedef&quot;&gt;为常用的块类型创建typedef&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return_type (^block_name)(parameters)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了隐藏复杂的块类型，需要用到C语言中名为类型定义的特性。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int (^EOCSomeBlock)(BOOL  flag,  int value);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;声明变量时，把名称放在类型中间，并在前面加上“^”符号。以下来创建变量，直接使用新类型即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EOCSomeBlock  block =  ^(BOOL  flag,  int value){
//Impementation
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;以&lt;code class=&quot;highlighter-rouge&quot;&gt;typedef&lt;/code&gt;重新定义块类型，可令块变量用起来更加简单。&lt;/li&gt;
  &lt;li&gt;定义新类型时应遵从现有的命名习惯，勿使其名称与别的类型冲突。&lt;/li&gt;
  &lt;li&gt;不妨为同一块签名定义多个类型别名。如果需要重构的代码使用了块类型的某个别名，那么只需修改相应&lt;code class=&quot;highlighter-rouge&quot;&gt;typedef&lt;/code&gt;中的块签名即可，无需改动其他&lt;code class=&quot;highlighter-rouge&quot;&gt;typedef&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;用handler块来降低代码分散程度&quot;&gt;用handler块来降低代码分散程度&lt;/h2&gt;

&lt;p&gt;编写代码时，经常会遇到一种范式，就是“异步执行任务”。异步方法执行完任务后，需要以某种手段通知代码。实现这种功能有很多方法，常用技巧是委托协议令关注此事件的对象遵从该协议。对象成为&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt;之后，就可以在相关事件发生时得到通知了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

@class EOCNetWorkFetcher;
@protocol EOCNetWorkFetcherDelegate &amp;lt;NSObject&amp;gt;
- (void)netWorkFetcher:(EOCNetWorkFetcher *)fetcher didFinishWithData:(NSData *)data;
@end

@interface EOCNetWorkFetcher : NSObject
@property (nonatomic, weak) id&amp;lt;EOCNetWorkFetcherDelegate&amp;gt; delegate;
- (void)initWithUrl:(NSURL *)url;
- (void)start;
@end;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其他类调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)fetchFooData{
NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.xvideos.com&quot;];
EOCNetWorkFetcher *fetcher = [[EOCNetWorkFetcher alloc] initWithURL:url];
fetcher.delegate = self;
[fetcher start];
}

- (void)netWorkFetcher:(EOCNetWorkFetcher *)fetcher didFinishWithData:(NSData *)data
{
_fetcherFooData = data;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 29 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/29/%E5%B0%86%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E5%88%86%E6%95%A3%E5%88%B0%E4%BE%BF%E4%BA%8E%E7%AE%A1%E7%90%86%E7%9A%84%E6%95%B0%E4%B8%AA%E5%88%86%E7%B1%BB%E4%B8%AD/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/29/%E5%B0%86%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E5%88%86%E6%95%A3%E5%88%B0%E4%BE%BF%E4%BA%8E%E7%AE%A1%E7%90%86%E7%9A%84%E6%95%B0%E4%B8%AA%E5%88%86%E7%B1%BB%E4%B8%AD/</guid>
        
        <category>iOS</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
  </channel>
</rss>
